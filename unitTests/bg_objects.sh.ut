#!/usr/bin/env bg-utRunner

import bg_objects.sh  ;$L1;$L2

function heapNameAnon()
{
	sed 's/heap_\([^_]*\)_\([^_ ]*\)/heap_\1_<redacted>/g'
}

function tempFileAnon()
{
	sed 's|bgmktemp\.\([^ ]*\)|bgmktemp\.<redacted>|g'
}

declare -A ut__parseObjSyntax=(
	[pOfEmptyOp0]="$(cmdline ".foo")"
	[pOfEmptyOp1]="$(cmdline ".bar.foo")"
	[pOfEmptyOp2]="$(cmdline ".foo p1")"
	[pOfEmptyOp3]="$(cmdline ".bar.foo p1")"

	[pOfUnsetOp0]="$(cmdline ".unset")"
	[pOfUnsetOp1]="$(cmdline ".foo.unset")"
	[pOfUnsetOp2]="$(cmdline ".unset p1")"
	[pOfUnsetOp3]="$(cmdline ".foo.unset p1")"

	[pOfNewOp0]="$(cmdline "=new")"
	[pOfNewOp1]="$(cmdline ".foo=new")"
	[pOfNewOp2]="$(cmdline "=new p1")"
	[pOfNewOp3]="$(cmdline ".foo=new p1")"

	[pOfAssignOp0]="$(cmdline "=")"
	[pOfAssignOp1]="$(cmdline ".foo=")"
	[pOfAssignOp2]="$(cmdline "= p1")"
	[pOfAssignOp3]="$(cmdline "=p1")"
	[pOfAssignOp4]="$(cmdline ".foo= p1")"
	[pOfAssignOp5]="$(cmdline ".foo=p1")"
)
function ut__parseObjSyntax() {
	ut setup
	local memberChain memberOp argsV
	ut test
	echo "'$*'"; _parseObjSyntax  memberChain memberOp argsV "$@"; printfVars memberChain memberOp argsV
}


function ut_initialState()
{
	# expect: shows the classes that ae initially created and their content
	ut setup
	function showClass() {
		local class="$1"
		printf "#\n#\n#------------------ $class --------------------\n"
		eval local globalArrayVars='"${!'"$class"'*}"'
		echo "global array vars: $globalArrayVars"
		printfVars --noObjects $class -l"#" ${class}_vmt "$(strSetSubtract "$globalArrayVars" "$class  ${class}_vmt")"
	}
	ut test
	echo Object ${Object[subClasses]}
	local class; for class in Object ${Object[subClasses]}; do
		showClass "$class"
	done
}

function ut_isA()
{
	# expect: that true tests indicate true and false tests indicate false
	ut setup
	DeclareClass Animal
	DeclareClass Dog : Animal

	ut test
	ut expect "these to be true"
	$Dog.isA "Animal"       && echo yes || echo no
	$Animal.isA "Animal"    && echo yes || echo no
	$Dog.isA "Object"       && echo yes || echo no

	echo
	ut expect "these to be false"
	$Animal.isA "Dog"       && echo yes || echo no
	$Animal.isA "Dog" # to document the return code
	$Animal.isA "Car"       && echo yes || echo no
}


function ut_getClassMethods()
{
	# expect: the correct set of methods to be printed to stdout. -i includes inherited, -d changes the delimiter between methods
	ut setup
	DeclareClass Animal
	Animal::speak() { echo "I am just an animal"; }
	Animal::pet() { echo "that's nice"; }
	Animal::feed() { echo "now that's more like it!"; }

	ut test
	$Animal.getClassMethods
	$Animal.getClassMethods -i
	$Animal.getClassMethods -d$'\n'
}


function ut_ConstructObject()
{
	# expect: the state after constructing a object 3 different ways is all consistent with each other
	ut setup
	DeclareClass Animal
	Animal::__construct() {
		this[species]="unk"
		this[family]="unk"
		this[legCount]="unk"
	}
	Animal::speak() { echo "I am just an animal"; }
	Animal::pet() { echo "that's nice"; }
	Animal::feed() { echo "now that's more like it!"; }

	ut test
	local pet; ConstructObject Animal pet
	local petOID="$(GetOID "$pet")"
	eval 'local petOIDVars="${!'"$petOID"'*}"'
	echo "global vars for this object = ${petOIDVars}" | heapNameAnon
	printfVars --noObjects pet $petOIDVars | heapNameAnon

	ut test
	local -A pet2; ConstructObject Animal pet2
	local pet2OID="$(GetOID "$pet2")"
	eval 'local pet2OIDVars="${!'"$pet2OID"'*}"'
	echo "vars for this object = ${pet2OIDVars}" | heapNameAnon
	printfVars --noObjects $pet2OIDVars | heapNameAnon

	ut test
	local -n pet3; ConstructObject Animal pet3
	local pet3OID="$(GetOID "$pet3")"
	eval 'local pet3OIDVars="${!'"$pet3OID"'*}"'
	echo "global vars for this object = ${pet3OIDVars}" | heapNameAnon
	printfVars --noObjects pet3 $pet3OIDVars | heapNameAnon
}


function ut__classUpdateVMT()
{
	# expect:
	ut setup
	DeclareClass Animal
	Animal::speak() { echo "I am just an animal"; }
	$Animal.getClassMethods

	ut test
	Animal::pet() { echo "that's nice"; }
	Animal::feed() { echo "now that's more like it!"; }

	ut expect: that pet and feed are not in this list
	echo "${Animal[methods]}"

	_classUpdateVMT -f "Animal"

	ut expect: that now pet and feed are in this list
	echo "${Animal[methods]}"
}


function ut_Array()
{
	ut test
	local -n a1; ConstructObject Array a1
	printfVars a1
	a1=(one two three)
	printfVars a1

	ut test
	local a2; ConstructObject Array a2
	$a2.getOID | heapNameAnon
	local -n a2OID; $a2.getOID a2OID
	printfVars a2
	a2OID=(one two three)
	printfVars a2
	$a2.getSize
}


function ut_Map()
{
	ut test
	local -n a1; ConstructObject Map a1
	printfVars a1
	a1=([one]=1 [two]=2 [three]=3)
	printfVars a1

	ut test
	local a2; ConstructObject Map a2
	$a2.getOID | heapNameAnon
	printfVars --noObjects "$($a2.getOID)"{,_sys} | heapNameAnon
	local -n a2OID; $a2.getOID a2OID
	printfVars a2
	a2OID=([one]=1 [two]=2 [three]=3)
	$a2.getIndexes
	printfVars a2
	printfVars --noObjects "$($a2.getOID)"{,_sys} | heapNameAnon
	$a2.getSize
}


function ut_Stack()
{
	ut test
	local -n a1; ConstructObject Stack a1
	printfVars a1
	$a1.push one
	$a1.push two
	$a1.push three
	$a1.getSize
	printfVars a1

	for ((i=0; i<$($a1.getSize); i++)); do $a1.peek $i; done

	local element
	while $a1.pop element; do printfVars element; done

	ut test
	local a2; ConstructObject Stack a2
	printfVars a2
	$a2.push one
	$a2.push two
	$a2.push three
	$a2.getSize
	printfVars a2

	for ((i=0; i<$($a2.getSize); i++)); do $a2.peek $i; done

	local element
	while $a2.pop element; do printfVars element; done
}

function ut_nestedObjects()
{
	# expect: the DataFile::read() method refer to "filename" and "data" directly without using the array notation this[filename]
	ut setup
	DeclareClass DataFile
	DataFile::__construct() {
		this[filename]="$1"; shift
		$_this.data=new Array
		$_this.read
	}
	DataFile::read() {
		if [ -f "$filename" ]; then
			mapfile -t data <"$filename"
		fi
	}
	local tmpFile; bgmktemp tmpFile
	echo "$(dedent '
		one fish
		two fish
		red fish
		blue fish
	')" | tee "$tmpFile"

	ut test
	ConstructObject DataFile datafile "$tmpFile"
	printfVars datafile  | tempFileAnon
}

function ut_Object_unset() {
	ut setup
	local -n obj; ConstructObject Object obj
	ut test
	obj[foo]="hello"
	ut expect that foo is present
	printfVars obj
	$obj.foo.unset

	ut expect that foo is not present
	printfVars obj
}

function ut_Object_exists() {
	ut setup
	local -n obj; ConstructObject Object obj
	ut test
	ut expect that foo does not exist
	$obj.foo.exists && echo true || echo false

	obj[foo]="hello"
	ut expect that foo exists now
	$obj.foo.exists && echo true || echo false
}

function ut_Object_isA() {
	ut setup
	local -n obj; ConstructObject Object obj
	ut test
	ut expect that only isA object will be true
	$obj.isA Object && echo true || echo false
	$obj.isA Array  && echo true || echo false
	$obj.isA Foo    && echo true || echo false
}

function ut_Object_assignNewOp() {
	ut setup
	local -n obj; ConstructObject Object obj
	ut test
	$obj.foo=new Array
	printfVars obj
}

function ut_Object_staticCallSyntax() {
	ut setup
	local -n obj; ConstructObject Object obj
	ut test
	ut expect that the Object class object is printed
	$obj.static.toString
}

function ut_Object_chainCallSyntax() {
	ut setup
	local -n obj; ConstructObject Object obj
	$obj.foo=new Map
	$obj.foo[bar]="hello world"
	ut test
	ut expect "that foo member's toString method is called"
	$obj.foo.toString

	ut expect "that object members can be created on demand"
	$obj.foo[one].two="yoyo"
	printfVars obj
}

function ut_Object_equalsOp() {
	ut setup
	local -n obj; ConstructObject Object obj
	$obj.num=5
	$obj.str="hello"

	ut test
	ut expect "that the new values are appended. This documents whether num is appended as a string or added"
	$obj.num+=10
	$obj.str+=" world"
	$obj.toString

	ut expect "equal to replace the previous value"
	$obj.num=10
	$obj.str="goodbye"
	$obj.toString
}

function ut_Object_virtualCallSyntax() {
	ut setup
	DeclareClass Base
	Base::one() { echo "Base::one"; }
	Base::two() { echo "Base::two"; }
	DeclareClass Derived : Base
	Derived::one() { echo "Derived::one"; $super.one; }
	Derived::two() { echo "Derived::two"; }
	local -n obj; ConstructObject Derived obj

	ut test
	ut expect "normal polymorphism -- to see only msg from Derived::two"
	$obj.two

	ut expect "explicit call -- to see only msg from Base::two"
	$obj.Base::two

	ut expect "polymorphism with super -- to see msg from Derived::one and then from Base:one"
	$obj.one
}

function ut_Object_memberVarReadAccess() {
	ut setup
	local -n obj; ConstructObject Object obj
	$obj.foo="hello world"
	ut test
	ut expect "to see what happens when we reference an attribute that exists"
	$obj.foo
	$obj[foo]
	ut expect "to see what happens when we reference an attribute that does not exist"
	$obj.bar
	$obj[bar]
	ut expect "to see what happens when we reference a method that does not exist (because it has arguments)"
	Try:
		$obj.doit p1 p2 p3
	Catch: && {
		echo "** Exception thrown and caught"
		printfVars catch_errorClass catch_errorCode catch_errorDescription | heapNameAnon
	}
	Try:
		$obj[doit] p1 p2 p3
	Catch: && {
		echo "** Exception thrown and caught"
		printfVars catch_errorClass catch_errorCode catch_errorDescription | heapNameAnon
	}
}
